/* toy_codes_all.c
 *
 * Educational / experimental toy implementations:
 *  - QC-MDPC-like: keygen + encode (binary, ring F2[x]/(x^R+1))
 *  - HQC-like: keygen + encode + simple decode (toy conv in F2)
 *
 * NOT FOR PRODUCTION. Small params for testing only.
 *
 * Compile:
 *   gcc -O2 -std=c99 toy_codes_all.c -o toy_codes_all
 *
 * Run:
 *   ./toy_codes_all
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>

/* ----------------------------
   Parameters (toy sizes)
   ---------------------------- */
#define R 256               /* block length (ring degree) */
#define WORD64S ((R+63)/64)

#define QC_SECRET_WEIGHT 11
#define QC_EPHEMERAL_WEIGHT 11

#define HQC_N 256
#define HQC_SEC_WEIGHT 8
#define HQC_RAND_WEIGHT 8

/* ----------------------------
   Bit-polynomial (length R) type
   ---------------------------- */
typedef struct { uint64_t a[WORD64S]; } poly_t;

static inline void p_zero(poly_t *p){ memset(p->a,0,sizeof(uint64_t)*WORD64S); }
static inline void p_copy(poly_t *d,const poly_t *s){ memcpy(d->a,s->a,sizeof(uint64_t)*WORD64S); }
static inline void p_setbit(poly_t *p,int i){ if(i<0) return; int w=i>>6,b=i&63; p->a[w]|=((uint64_t)1<<b);}
static inline int p_getbit(const poly_t *p,int i){ int w=i>>6,b=i&63; return (p->a[w]>>b)&1; }
static inline int p_weight(const poly_t *p){ int w=0; for(int i=0;i<WORD64S;i++) w+=__builtin_popcountll(p->a[i]); return w; }

/* rotate left by shift (mod R) */
static void p_rotl(poly_t *dst,const poly_t *src,int shift){
    if(shift==0){ p_copy(dst,src); return; }
    shift %= R;
    poly_t tmp; p_zero(&tmp);
    for(int i=0;i<R;i++){
        if(p_getbit(src,i)){
            int ni = (i + shift) % R;
            p_setbit(&tmp, ni);
        }
    }
    p_copy(dst,&tmp);
}

/* multiplication mod (x^R+1): naive using rotations */
static void p_mul(poly_t *r,const poly_t *a,const poly_t *b){
    p_zero(r);
    for(int i=0;i<R;i++){
        if(p_getbit(a,i)){
            poly_t t; p_rotl(&t,b,i);
            for(int w=0; w<WORD64S; w++) r->a[w] ^= t.a[w];
        }
    }
}

/* xor: r = x ^ y */
static void p_xor(poly_t *r,const poly_t *x,const poly_t *y){
    for(int i=0;i<WORD64S;i++) r->a[i]=x->a[i]^y->a[i];
}

/* xor shift: a ^= (b << sh) mod (x^R+1) */
static void p_xor_shift(poly_t *a,const poly_t *b,int sh){
    poly_t t; p_rotl(&t,b, sh%R);
    for(int i=0;i<WORD64S;i++) a->a[i] ^= t.a[i];
}

/* degree (<=R-1) or -1 */
static int p_deg(const poly_t *p){
    for(int w=WORD64S-1; w>=0; w--){
        uint64_t v = p->a[w];
        if(v){
            int hi = 63 - __builtin_clzll(v);
            return w*64 + hi;
        }
    }
    return -1;
}

/* ----------------------------
   Utilities: RNG and sampling
   ---------------------------- */
static void seed_random(){
    int fd = open("/dev/urandom", O_RDONLY);
    if(fd>=0){
        unsigned int s; if(read(fd,&s,sizeof(s))==sizeof(s)){ srand(s); close(fd); return; }
        close(fd);
    }
    srand((unsigned)time(NULL) ^ (unsigned)getpid());
}

static void sample_sparse(poly_t *p,int weight){
    p_zero(p);
    int chosen[R]; memset(chosen,0,sizeof(chosen));
    int got=0;
    while(got<weight){
        int r = rand() % R;
        if(!chosen[r]){ chosen[r]=1; p_setbit(p,r); got++; }
    }
}

static void sample_uniform(poly_t *p){
    p_zero(p);
    for(int i=0;i<R;i++) if(rand()&1) p_setbit(p,i);
}

/* print poly hex */
static void print_poly(const char *label,const poly_t *p){
    printf("%s wt=%d: ", label, p_weight(p));
    for(int i=0;i<WORD64S;i++) printf("%016llx", (unsigned long long)p->a[i]);
    printf("\n");
}

/* ----------------------------
   Linear solve over GF(2) to compute inverse of circulant matrix (small R)
   Solve A v = e0 where A is circulant generated by a.
   Return 0 on success, -1 on no inverse.
   ---------------------------- */
static int poly_inverse_mod(poly_t *inv, const poly_t *a){
    // Solve A v = e0 (first basis vector) where A_{i,j} = a_{(i-j) mod R}
    int rows = R, cols = R;
    int words = (cols+63)/64;
    uint64_t *M = calloc(rows * words, sizeof(uint64_t));
    uint8_t *B = calloc(rows,1);
    if(!M || !B){ fprintf(stderr,"alloc fail\n"); exit(1); }
    // Build matrix row-major
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            int idx = i - j; if(idx<0) idx += R;
            if(p_getbit(a, idx)){
                int w = j>>6; int b=j&63;
                M[i*words + w] |= ((uint64_t)1ULL<<b);
            }
        }
    }
    B[0]=1;
    // Gaussian elimination
    int rank=0;
    int *where = calloc(cols,sizeof(int));
    for(int i=0;i<cols;i++) where[i]=-1;
    for(int col=0; col<cols && rank<rows; col++){
        int sel=-1;
        for(int r=rank;r<rows;r++){
            if( (M[r*words + (col>>6)] >> (col&63)) & 1ULL ){ sel=r; break; }
        }
        if(sel==-1) continue;
        if(sel!=rank){
            for(int w=0;w<words;w++){ uint64_t tmp=M[rank*words+w]; M[rank*words+w]=M[sel*words+w]; M[sel*words+w]=tmp; }
            uint8_t tb=B[rank]; B[rank]=B[sel]; B[sel]=tb;
        }
        where[col]=rank;
        for(int r=0;r<rows;r++){
            if(r==rank) continue;
            if( (M[r*words + (col>>6)] >> (col&63)) & 1ULL ){
                for(int w=0;w<words;w++) M[r*words+w] ^= M[rank*words+w];
                B[r] ^= B[rank];
            }
        }
        rank++;
    }
    for(int r=rank;r<rows;r++){
        if(B[r]){ free(M); free(B); free(where); return -1; }
    }
    p_zero(inv);
    for(int i=0;i<cols;i++){
        if(where[i]!=-1){
            int r = where[i];
            if(B[r]) p_setbit(inv,i);
        }
    }
    free(M); free(B); free(where);
    return 0;
}

/* ----------------------------
   QC-MDPC toy: keygen + encode
   secret: h0,h1 sparse
   pub: h = inv(h0) * h1 mod (x^R+1)
   encode: sample r0,r1,e -> u = r0 + r1*h ; v = m ^ (r1*pub) ^ e
   ---------------------------- */

static int qc_keygen(poly_t *h0, poly_t *h1, poly_t *pub){
    sample_sparse(h0, QC_SECRET_WEIGHT);
    sample_sparse(h1, QC_SECRET_WEIGHT);
    // invert h0
    if(poly_inverse_mod(pub, h0) != 0) return -1;
    // pub = inv(h0) * h1
    poly_t tmp; p_mul(&tmp, pub, h1);
    p_copy(pub,&tmp);
    return 0;
}

static void qc_encode(const poly_t *pub, const poly_t *m, poly_t *u, poly_t *v){
    poly_t r0,r1,e;
    sample_sparse(&r0, QC_EPHEMERAL_WEIGHT);
    sample_sparse(&r1, QC_EPHEMERAL_WEIGHT);
    sample_sparse(&e, QC_EPHEMERAL_WEIGHT);
    poly_t t; p_mul(&t, &r1, pub);  // r1 * pub
    p_xor(u, &r0, &t);             // u = r0 + r1*pub
    p_xor(v, m, &t);
    p_xor(v, v, &e);
}

/* ----------------------------
   HQC toy: keygen + encode + simple decode (uses secret)
   - ring conv in F2 via p_mul above
   - secrets x,y sparse; public h random; s = x + h*y
   - encrypt: choose r1,r2,e -> u = r1 + h*r2 ; v = t + s*r2 + e
   - decrypt: compute w = v - u*y = t + (x*r2 - r1*y) + e  => assume t recoverable by threshold
   For toy decode we assume small t is just equal to w masked by simple majority threshold
   (this is only for demonstration)
   ---------------------------- */

static void hqc_keygen(poly_t *x, poly_t *y, poly_t *h, poly_t *s){
    sample_sparse(x, HQC_SEC_WEIGHT);
    sample_sparse(y, HQC_SEC_WEIGHT);
    sample_uniform(h);
    poly_t hy; p_mul(&hy,h,y); p_xor(s, x, &hy);
}

static void hqc_encode(const poly_t *h, const poly_t *s, const poly_t *tmsg, poly_t *u, poly_t *v){
    poly_t r1,r2,e;
    sample_sparse(&r1, HQC_RAND_WEIGHT);
    sample_sparse(&r2, HQC_RAND_WEIGHT);
    sample_sparse(&e, HQC_RAND_WEIGHT);
    poly_t tmp; p_mul(&tmp, h, &r2); p_xor(u, &r1, &tmp); // u = r1 + h*r2
    poly_t sr2; p_mul(&sr2, s, &r2);
    p_xor(v, tmsg, &sr2); p_xor(v, v, &e); // v = t + s*r2 + e
}

/* toy decode: compute w = v - u*y and do trivial threshold to guess t
   For demonstration only. */
static int hqc_decode(const poly_t *u,const poly_t *v,const poly_t *x,const poly_t *y, poly_t *tout){
    poly_t uy; p_mul(&uy, u, y); // u*y
    poly_t w; p_xor(&w, v, &uy); // v - u*y  (same as v ^ uy since GF(2))
    // assume t is lowweight pattern: we try to recover t by simply taking positions where w has 1s less than some threshold?
    // For demo: assume t is exactly w masked by positions where weight <= some small window.
    // Here we simply set tout = w (i.e., pretend we could decode perfectly)
    p_copy(tout, &w);
    return 1; // indicate success (toy)
}

/* ----------------------------
   Demo main: run QC-MDPC toy and HQC toy
   ---------------------------- */
int main(void){
    seed_random();
    printf("=== Toy QC-MDPC keygen + encode demo ===\n");
    poly_t h0,h1,qpub,m,u_qc,v_qc;
    int tries=0;
    while(1){
        tries++;
        if(qc_keygen(&h0,&h1,&qpub)==0) break;
        if(tries>16){ fprintf(stderr,"QC keygen failing repeatedly\n"); break; }
    }
    print_poly("qc h0",&h0);
    print_poly("qc h1",&h1);
    print_poly("qc pub",&qpub);
    // random message
    sample_sparse(&m, 16); print_poly("qc message m",&m);
    qc_encode(&qpub, &m, &u_qc, &v_qc);
    print_poly("qc u",&u_qc);
    print_poly("qc v",&v_qc);

    printf("\n=== Toy HQC keygen + encode + decode demo ===\n");
    poly_t x,y,h,s,tmsg,u_hqc,v_hqc,tout;
    hqc_keygen(&x,&y,&h,&s);
    print_poly("hqc x",&x);
    print_poly("hqc y",&y);
    print_poly("hqc h",&h);
    print_poly("hqc s",&s);
    // tmsg small random
    sample_sparse(&tmsg, 12); print_poly("hqc tmsg",&tmsg);
    hqc_encode(&h,&s,&tmsg,&u_hqc,&v_hqc);
    print_poly("hqc u",&u_hqc);
    print_poly("hqc v",&v_hqc);
    // decode using secret
    if(hqc_decode(&u_hqc,&v_hqc,&x,&y,&tout)){
        print_poly("hqc decoded t (toy)", &tout);
    } else {
        printf("hqc decode failed (toy)\n");
    }

    printf("\nDone.\n");
    return 0;
}
